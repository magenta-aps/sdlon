# SPDX-FileCopyrightText: Magenta ApS
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from uuid import UUID

from sqlalchemy import delete
from sqlalchemy import desc
from sqlalchemy import select
from sqlalchemy.orm import sessionmaker
from structlog import get_logger

from db.engine import get_engine
from db.models import Payload
from db.models import Runs
from sdlon.metrics import RunDBState

logger = get_logger()

Session = sessionmaker()


def log_payload(
    request_uuid: UUID,
    full_url: str,
    params: str,
    response: str,
    status_code: int,
) -> None:
    """Log a given SD payload to the payload database

    Args:
        request_uuid: Unique UUID of this API request. Must be generated by the caller.
        full_url: Full URL of API endpoint called, e.g. containing the SD server name.
        params: Stringified version of the `payload` variable in `sd_lookup`.
        response: The raw/unparsed XML response from the SD API endpoint called.
        status_code: The HTTP status code from the SD API endpoint called.
    """
    Session.configure(bind=get_engine())
    session = Session()
    payload = Payload(
        id=request_uuid,
        full_url=full_url,
        params=params,
        response=response,
        status_code=status_code,
    )
    session.add(payload)
    session.commit()


def get_status() -> RunDBState:
    try:
        Session.configure(bind=get_engine())
        with Session() as session:
            statement = select(Runs.status).order_by(desc(Runs.id)).limit(1)
            status = session.execute(statement).scalar_one_or_none()

            # status is only "None" the very first time the application is run
            # and should in this case return "COMPLETED" in order to not abort
            # the run when get_status() is called.
            if status == RunDBState.RUNNING.value:
                return RunDBState.RUNNING
            if status == RunDBState.COMPLETED.value or status is None:
                return RunDBState.COMPLETED
            return RunDBState.UNKNOWN
    except Exception as error:
        logger.error("Could not get RunDB status!", error=error)
        return RunDBState.UNKNOWN


def persist_status(from_date: datetime, to_date: datetime, status: RunDBState) -> None:
    Session.configure(bind=get_engine())
    with Session() as session:
        run = Runs(from_date=from_date, to_date=to_date, status=status.value)
        session.add(run)
        session.commit()


def get_run_db_from_date() -> datetime:
    Session.configure(bind=get_engine())
    with Session() as session:
        # Note: we use the last to_date as the new from_date
        statement = select(Runs.to_date).order_by(desc(Runs.id)).limit(1)
        from_date = session.execute(statement).scalar_one_or_none()
        return from_date


def delete_last_run() -> None:
    Session.configure(bind=get_engine())
    with Session() as session:
        statement = select(Runs.id, Runs.status).order_by(desc(Runs.id)).limit(1)
        last_run_id, status = session.execute(statement).fetchone()

        if status == RunDBState.COMPLETED:
            logger.warning("Last status is 'COMPLETED': No op")
            return

        statement = delete(Runs).where(Runs.id == last_run_id)
        session.execute(statement)
        session.commit()
